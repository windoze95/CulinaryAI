package main

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/sessions"
	"go.uber.org/ratelimit"
)

type PageData struct {
	TitlePrefix string
	User        *User
}

type limiterInfo struct {
	limiter  ratelimit.Limiter
	lastSeen time.Time
}

func startGin() {
	gin.SetMode(gin.ReleaseMode)
	router := gin.Default()
	var rpm int = 30
	router.Use(ipRateLimit(rpm, 10*time.Minute, 1*time.Hour))
	// globalLimiter = ratelimit.New(rpm, ratelimit.Per(60*time.Second))
	router.LoadHTMLGlob("templates/*.tmpl")
	router.Static("/static", "static")
	router.Use(SessionMiddleware())
	router.GET("/", func(c *gin.Context) {
		fmt.Println(c.Keys["session"])
		val, _ := c.Get("user")
		fmt.Println(val)
		// if !exists {
		// 	// This may be nil, in some cases that will simply be replaced with a cheesy placeholder
		// 	// This means the UserMiddleware did not run or did not find a user
		// 	// You may decide to return an error or handle this situation differently
		// 	c.JSON(http.StatusInternalServerError, gin.H{"error": "No user information"})
		// 	return
		// }

		user, _ := val.(*User)
		fmt.Println(user)
		// if !ok {
		// 	// This means the user was not of type *User
		// 	// This should not happen if UserMiddleware is functioning correctly
		// 	c.JSON(http.StatusInternalServerError, gin.H{"error": "User information is of the wrong type"})
		// 	return
		// }

		pageData := PageData{
			TitlePrefix: gc.Title,
			User:        user,
		}
		c.HTML(http.StatusOK, "index.tmpl", pageData)
	})

	// Registration page
	router.GET("/signup", func(c *gin.Context) {
		c.HTML(http.StatusOK, "signup.tmpl", gin.H{})
	})

	// User sign up
	router.POST("/users", signupUserHandler)

	// Login page
	router.GET("/login", func(c *gin.Context) {
		c.HTML(http.StatusOK, "login.tmpl", gin.H{})
	})

	// User login
	router.POST("/login", UserMiddleware(), loginUserHandler)

	// User settings
	router.PUT("/users/:id/settings", UserMiddleware(), UserOwnerMiddleware(), func(c *gin.Context) {})

	// Recipe generation
	// router.POST("/users/:id/recipes", func(c *gin.Context) {})
	router.POST("/recipes", UserMiddleware(), func(c *gin.Context) {})

	// Viewing recipes generated by a user
	router.GET("/users/:id/recipes", UserMiddleware(), func(c *gin.Context) {
		// This new route might be used to get all recipes generated by a specific user.
	})

	// Viewing the recipes collected by a user
	router.GET("/users/:id/collected", UserMiddleware(), func(c *gin.Context) {
		// This new route might be used to get all recipes collected by a specific user.
	})

	// Viewing saved recipes from all users
	router.GET("/recipes/collected", func(c *gin.Context) {})

	// Viewing trashed recipes from all users (Deletes on expiration)
	// router.GET("/recipes/trash", func(c *gin.Context) {})

	// Collecting any existing recipe
	router.PUT("/users/:id/recipes/:recipe_id/collect", UserMiddleware(), UserOwnerMiddleware(), collectRecipeHandler)

	// Deleting a recipe by the user who generated it
	router.DELETE("/users/:id/recipes/:recipe_id", func(c *gin.Context) {
		// userID := c.Param("id")
		userID, err := strconv.ParseUint(c.Param("id"), 10, 32)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid user ID"})
			return
		}
		recipeID := c.Param("recipe_id")

		var recipe Recipe
		if err := db.Where("id = ?", recipeID).First(&recipe).Error; err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "Recipe not found"})
			return
		}

		if recipe.UserID != uint(userID) {
			c.JSON(http.StatusForbidden, gin.H{"error": "User not authorized to delete this recipe"})
			return
		}
		timeNow := time.Now()
		recipe.DeletedAt = &timeNow
		db.Save(&recipe)

		c.JSON(http.StatusOK, gin.H{"message": "Recipe deleted"})
	})

	// Collecting a recipe from the trash
	router.PUT("/users/:id/trash/:recipe_id/collect", func(c *gin.Context) {
		userID := c.Param("id")
		recipeID := c.Param("recipe_id")

		var recipe Recipe
		if err := db.Where("id = ?", recipeID).First(&recipe).Error; err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "Recipe not found"})
			return
		}

		if recipe.DeletedAt == nil || recipe.DeletedAt.AddDate(0, 0, 30).Before(time.Now()) {
			c.JSON(http.StatusForbidden, gin.H{"error": "Recipe is not in trash"})
			return
		}

		var user User
		if err := db.Where("id = ?", userID).First(&user).Error; err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
			return
		}

		recipe.GeneratedBy = nil
		recipe.DeletedAt = nil
		user.CollectedRecipes = append(user.CollectedRecipes, recipe)

		db.Save(&user)
		db.Save(&recipe)

		c.JSON(http.StatusOK, gin.H{"message": "Recipe collected from trash"})
	})

	// Viewing trashed recipes from all users
	router.GET("/recipes/trash", func(c *gin.Context) {
		var recipes []Recipe
		db.Where("deleted_at IS NOT NULL AND deleted_at > ?", time.Now().AddDate(0, 0, -30)).Find(&recipes)

		c.JSON(http.StatusOK, gin.H{"recipes": recipes})
	})

	port := os.Getenv(gc.Env.Port)
	if port == "" {
		log.Fatalf("%s must be set", gc.Env.Port)
	}
	router.Run(":" + port)
}

func ipRateLimit(rpm int, cleanupInterval time.Duration, expiration time.Duration) gin.HandlerFunc {
	limiters := make(map[string]*limiterInfo)
	var mu sync.Mutex

	// Cleanup goroutine
	go func() {
		for range time.Tick(cleanupInterval) {
			mu.Lock()
			for ip, info := range limiters {
				if time.Since(info.lastSeen) > expiration {
					delete(limiters, ip)
				}
			}
			mu.Unlock()
		}
	}()

	return func(ctx *gin.Context) {
		ip := ctx.ClientIP()
		mu.Lock()
		info, exists := limiters[ip]
		if !exists {
			info = &limiterInfo{
				limiter:  ratelimit.New(rpm, ratelimit.Per(60*time.Second)),
				lastSeen: time.Now(),
			}
			limiters[ip] = info
		}
		info.lastSeen = time.Now()
		mu.Unlock()

		info.limiter.Take()
	}
}

// func globalRateLimit(ctx *gin.Context) {
// 	userSettings := loadUserSettings(ctx)
// 	if userSettings.OpenAIKey != "" {
// 		globalLimiter.Take()
// 	}
// }

func SessionMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		session, err := store.Get(c.Request, "session-name") // Replace with your real session name
		if err != nil {
			// Handle error. For example:
			c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get session"})
			c.Abort()
			return
		}
		c.Set("session", session)
		c.Next()
	}
}

func UserOwnerMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Retrieve user's session
		session := c.MustGet("session").(*sessions.Session)

		// Extract authenticated user's ID from the session
		authenticatedUserID := session.Values["userID"]

		// Extract user ID from URL
		userID := c.Param("id")

		// Check if the authenticated user's ID matches the user ID in the URL
		if authenticatedUserID != userID {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "You are not authorized to perform this action."})
			c.Abort()
			return
		}

		c.Next()
	}
}

func UserMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		user := getSessionUser(c)
		if user == nil {
			c.Set("user", nil)
		} else {
			c.Set("user", user)
		}

		c.Next()
	}
}
