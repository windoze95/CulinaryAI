package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	goaway "github.com/TwiN/go-away"
	"github.com/asaskevich/govalidator"
	"github.com/gin-gonic/gin"
	"github.com/gorilla/sessions"
	"github.com/jinzhu/gorm"
	openai "github.com/sashabaranov/go-openai"
	"golang.org/x/crypto/bcrypt"
)

type HTTPError struct {
	Code    int
	Message string
	Err     error
}

// func (e *HTTPError) Error() string {
// 	return e.Message
// }

// Handler for viewing a single recipe
func viewRecipeHandler(c *gin.Context) {
	recipeID := c.Param("recipe_id") // Get the recipe ID from the URL parameter

	var recipe Recipe
	// Fetch the recipe by its ID
	if err := db.Where("id = ?", recipeID).First(&recipe).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Recipe not found"})
		return
	}

	// val, ok := c.Get("user")
	// if !ok {
	// 	c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid user data"})
	// 	return
	// }

	// user, ok := val.(*User)
	// if !ok {
	// 	c.JSON(http.StatusInternalServerError, gin.H{"error": "User data is of the wrong type"})
	// 	return
	// }

	// Fetch the recipe by its ID
	if err := db.Preload("GuidingContent").
		Preload("Tags").
		Preload("GeneratedBy", func(db *gorm.DB) *gorm.DB {
			return db.Select("Username")
		}).
		Where("id = ?", recipeID).
		First(&recipe).Error; err != nil {
		if gorm.IsRecordNotFoundError(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Recipe not found"})
		} else {
			log.Printf("Error fetching recipe: %v", err)
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Internal Server Error"})
		}
		return
	}

	c.JSON(http.StatusOK, gin.H{"recipe": recipe})
}

func generateRecipeHandler(c *gin.Context) {
	// Retrieve the user from the context
	user, err := getUserFromContext(c)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Parse the request body for the user's prompt
	var request struct {
		UserPrompt string `json:"userPrompt"`
	}

	if err := c.BindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request: " + err.Error()})
		return
	}

	// Populate basic Recipe fields
	recipe := Recipe{
		GeneratedBy:       user,
		UserPrompt:        request.UserPrompt,
		GuidingContent:    &user.GuidingContent,    // Set from user's existing GuidingContent
		GuidingContentUID: user.GuidingContent.UID, // Set from user's existing GuidingContent
	}

	// Save the basic Recipe details to the database
	if err := db.Create(&recipe).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save initial recipe: " + err.Error()})
		return
	}

	// The recipe now has an ID generated by the database
	c.JSON(http.StatusOK, gin.H{"recipe": recipe, "message": "Initial recipe saved, ready for FullRecipe update"})

	// Create a new context with a 5-minute timeout
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Use a Done channel to signal completion
	done := make(chan bool)

	go func(ctx context.Context) {
		// Choose an api key
		key, err := chooseAPIKey(user)
		if err != nil {
			log.Printf("error: %v", err)
			return
		}

		// Create a new chat service instance with the user's decrypted key
		chatService, err := NewOpenaiClient(key)
		if err != nil {
			log.Printf("error: failed to create chat service: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create chat service: " + err.Error()})
			return
		}

		// Create the chat completion with the user's prompt
		recipeContent, err := chatService.CreateRecipeChatCompletion(user.GuidingContent.Requirements, request.UserPrompt)
		if err != nil {
			log.Printf("error: failed to create recipe chat completion: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create recipe: " + err.Error()})
			return
		}

		recipe.FullRecipe = *recipeContent
		// Serialize FullRecipe to FullRecipeJSON
		if err := recipe.SerializeFullRecipe(); err != nil {
			log.Printf("error: failed to serialize FullRecipe: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to serialize FullRecipe: " + err.Error()})
			return
		}

		// Update the FullRecipeJSON field in the database
		if err := db.Model(&recipe).Update("FullRecipeJSON", recipe.FullRecipeJSON).Error; err != nil {
			log.Printf("error: failed to update FullRecipeJSON in database: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update FullRecipeJSON in database: " + err.Error()})
			return
		}

		// Associate tags with the recipe
		if err := associateTagsWithRecipe(&recipe); err != nil {
			log.Printf("error: %v", err)
			return
		}

		// Serialize FullRecipe back to a JSON string
		if err := recipe.SerializeFullRecipe(); err != nil {
			log.Printf("error: failed to serialize FullRecipe: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to serialize FullRecipe"})
			return
		}

		// Update the existing Recipe record with FullRecipe
		if err := db.Model(&recipe).Update("FullRecipeJSON", recipe.FullRecipeJSON).Error; err != nil {
			log.Printf("error: failed to update recipe with FullRecipe: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update recipe with FullRecipe"})
			return
		}

		imageService, err := NewOpenaiClient(key)
		if err != nil {
			log.Printf("error: failed to create image service: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create image service: " + err.Error()})
			return
		}

		imageBytes, err := imageService.CreateImage(recipeContent.DallEPrompt)
		if err != nil {
			log.Printf("error: failed to create recipe image: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create recipe image: " + err.Error()})
			return
		}

		imageURL, err := UploadRecipeImageToS3(imageBytes)
		if err != nil {
			log.Printf("error: failed to upload image to S3: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to upload image to S3: " + err.Error()})
			return
		}

		// Update the existing Recipe record with the image URL
		if err := db.Model(&recipe).Update("ImageURL", imageURL).Error; err != nil {
			log.Printf("error: failed to update recipe with image URL: %v", err)
			// c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update recipe with image URL: " + err.Error()})
			return
		}

		// Signal completion
		done <- true
	}(ctx)

	// Wait for the goroutine to finish or timeout
	select {
	case success := <-done:
		if success {
			// Mark the generation as complete
			recipe.GenerationComplete = true
			if err := db.Model(&recipe).Update("GenerationComplete", true).Error; err != nil {
				// Log error
				log.Println("error: Failed to update GenerationComplete:", err)
			}
		} else {
			// Log the failure case
			// More specific logging of the error is done in the goroutine
			log.Println("error: Failed to generate recipe")
		}
	case <-ctx.Done():
		// Log the timeout case
		log.Println("error: Incomplete recipe generation: timed out after 5 minutes")
	}

	// Close the Done channel
	close(done)
}

// Handler for collecting a recipe
func collectRecipeHandler(c *gin.Context) {
	userID := c.Param("id")
	recipeID := c.Param("recipe_id")

	var recipe Recipe
	if err := db.Where("id = ?", recipeID).First(&recipe).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Recipe not found"})
		return
	}

	if recipe.DeletedAt != nil {
		recipe.GeneratedBy = nil
		recipe.DeletedAt = nil
	}

	var user User
	if err := db.Where("id = ?", userID).First(&user).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}

	// Check if the recipe still exists just before trying to modify it
	if err := db.Where("id = ?", recipeID).First(&Recipe{}).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Recipe no longer exists"})
		return
	}

	user.CollectedRecipes = append(user.CollectedRecipes, recipe)

	db.Save(&user)
	db.Save(&recipe)

	c.JSON(http.StatusOK, gin.H{"message": "Recipe collected"})
}

func getSettingsHandler(c *gin.Context) {
	// Retrieve the user from the context
	user, err := getUserFromContext(c)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	// Check the validity of the OpenAI key by making a test API call
	isValid, err := verifyOpenAIKey(user.Settings.EncryptedOpenAIKey)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	if !isValid {
		c.HTML(http.StatusOK, "settings.tmpl", gin.H{"isValid": false, "user": user})
		return
	}

	// Render the settings modal template with valid key and user data
	c.HTML(http.StatusOK, "settings.tmpl", gin.H{"isValid": true, "user": user})
}

func verifyOpenAIKey(encryptedOpenAIKey string) (bool, error) {
	// Set as invalid if no key exists yet
	if encryptedOpenAIKey == "" {
		return false, nil
	}

	// Decrypt the OpenAI key
	key, err := decryptOpenAIKey(encryptedOpenAIKey)
	if err != nil {
		return false, errors.New("failed to decrypt OpenAI key:" + err.Error())
	}

	// Set up OpenAI client with the given key
	client := openai.NewClient(key)
	ctx := context.Background()

	// Maximum number of retries
	const maxRetries = 3

	// Delay between retries
	const retryDelay = 10 * time.Second

	// Attempt the verification with retries
	for attempt := 0; attempt < maxRetries; attempt++ {
		// Make a test API call using a minimal completion request
		req := openai.CompletionRequest{
			Model:     openai.GPT3Ada,
			MaxTokens: 5,
			Prompt:    "Test",
		}
		_, err := client.CreateCompletion(ctx, req)

		// Check for specific API errors
		e := &openai.APIError{}
		if errors.As(err, &e) {
			switch e.HTTPStatusCode {
			case 401:
				// Invalid auth or key (do not retry)
				return false, nil
			case 429:
				// Rate limiting or engine overload (wait and retry)
				time.Sleep(retryDelay)
				continue
			case 500:
				// OpenAI server error (retry)
				continue
			default:
				// Unhandled error (do not retry)
				// return false, err
				return true, err
			}
		}

		// If the call was successful, the key is valid
		if err == nil {
			return true, nil
		}
	}

	// If all attempts failed, return false
	return false, errors.New("failed to verify OpenAI key after multiple attempts")
}

func updateUserSettingsHandler(c *gin.Context) {
	// Retrieve the user from the session
	val, ok := c.Get("user")
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "No user information"})
		return
	}

	user, ok := val.(*User)
	if !ok {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "User information is of the wrong type"})
		return
	}

	// Parse the new OpenAI key from the request body
	var newSettings struct {
		OpenAIKey string `json:"apikey"`
	}
	if err := c.ShouldBindJSON(&newSettings); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var openAIKeyChanged = newSettings.OpenAIKey != ""

	// Check if the OpenAI key has been entered
	if openAIKeyChanged {
		// Encrypt the OpenAI key before storing
		encryptedOpenAIKey, err := encryptOpenAIKey(newSettings.OpenAIKey)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to encrypt OpenAI key: " + err.Error()})
			return
		}

		// Update the user's OpenAI key in the UserSettings
		// user.Settings.EncryptedOpenAIKey = encryptedOpenAIKey
		// if err := db.Model(&user.Settings).Update("EncryptedOpenAIKey", user.Settings.EncryptedOpenAIKey).Error; err != nil {
		// 	c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update settings"})
		// 	return
		// }
		if err := db.Model(&UserSettings{}).Where("user_id = ?", user.ID).Update("EncryptedOpenAIKey", encryptedOpenAIKey).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update settings"})
			return
		}
	}

	// This won't seem as redundant when more settings are && added
	if openAIKeyChanged {
		c.JSON(http.StatusOK, gin.H{"message": "Settings updated successfully"})
	} else {
		c.JSON(http.StatusOK, gin.H{"message": "No changes made"})
	}
}

// Handler for logging in a user
func loginUserHandler(c *gin.Context) {
	var userCredentials struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
	}

	// Returns error if a required field is not included
	if err := c.ShouldBindJSON(&userCredentials); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var user User
	if err := db.Where("username = ?", userCredentials.Username).First(&user).Error; err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid username or password"})
		return
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.HashedPassword), []byte(userCredentials.Password)); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid username or password"})
		return
	}

	session := c.MustGet("session").(*sessions.Session)
	session.Values["user_id"] = user.ID
	// session.Values["user"] = user
	session.Save(c.Request, c.Writer)

	c.JSON(http.StatusOK, gin.H{"message": "User logged in successfully"})
}

func signupUserHandler(c *gin.Context) {
	var newUser struct {
		Username string `json:"username" binding:"required"`
		Password string `json:"password" binding:"required"`
	}

	// Returns error if a required field is not included
	if err := c.ShouldBindJSON(&newUser); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "All fields are required"})
		return
	}

	if err := validateUsername(newUser.Username); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newUser.Password), bcrypt.DefaultCost)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error hashing password"})
		return
	}

	user := User{
		Username:       newUser.Username,
		HashedPassword: string(hashedPassword),
	}

	if err := db.Create(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error creating user"})
		return
	}

	userSettings := UserSettings{
		UserID: user.ID, // Use the ID of the newly created user
	}

	if err := db.Create(&userSettings).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error creating user settings"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "User signed up successfully"})
}

var forbiddenUsernames = []string{
	"admin",
	"administrator",
	"root",
	// "julian",
	"yana",
	"sys",
	"sysadmin",
	"system",
	"test",
	"testuser",
	"test-user",
	"test_user",
	"login",
	"logout",
	"register",
	"password",
	"user",
	"user123",
	"newuser",
	"yourapp",
	"yourcompany",
	"yourbrand",
	"support",
	"help",
	"faq",
	"culinaryai",
	"culinaryAI",
	"CulinaryAi",
	"CULINARYAI",
	"culinary_ai",
	"culinary-ai",
	"culinaryaiadmin",
	"culinaryai_admin",
	"culinaryai-admin",
	"culinaryairoot",
	"culinaryai_root",
	"culinaryai-root",
}

func validateUsername(username string) error {
	lowercaseUsername := strings.ToLower(username)

	var user User
	if err := db.Where("LOWER(username) = ?", lowercaseUsername).First(&user).Error; err == nil {
		return fmt.Errorf("username is already taken")
	}

	minLength := 3
	if len(username) < minLength {
		return fmt.Errorf("username must be at least %d characters", minLength)
	}

	if !govalidator.IsAlphanumeric(username) {
		return fmt.Errorf("username can only contain alphanumeric characters")
	}

	for _, forbiddenUsername := range forbiddenUsernames {
		if strings.EqualFold(lowercaseUsername, forbiddenUsername) {
			return fmt.Errorf("username '%s' is not allowed", username)
		}
	}

	// Profanity check using goaway library
	profanityDetector := goaway.NewProfanityDetector().WithSanitizeLeetSpeak(true).WithSanitizeSpecialCharacters(true).WithSanitizeAccents(false)
	if profanityDetector.IsProfane(username) {
		return fmt.Errorf("username contains inappropriate language")
	}

	// If we've passed all checks, the username is valid.
	return nil
}

func ValidatePassword(password string) error {
	if len(password) < 8 {
		return errors.New("password must be at least 8 characters long")
	}
	hasUppercase, _ := regexp.MatchString(`[A-Z]`, password)
	if !hasUppercase {
		return errors.New("password must contain at least one uppercase letter")
	}
	hasLowercase, _ := regexp.MatchString(`[a-z]`, password)
	if !hasLowercase {
		return errors.New("password must contain at least one lowercase letter")
	}
	hasNumber, _ := regexp.MatchString(`\d`, password)
	if !hasNumber {
		return errors.New("password must contain at least one digit")
	}
	hasSpecialChar, _ := regexp.MatchString(`[!@#$%^&*]`, password)
	if !hasSpecialChar {
		return errors.New("password must contain at least one special character")
	}
	return nil
}

func getUserFromContext(c *gin.Context) (*User, error) {
	val, ok := c.Get("user")
	if !ok {
		return nil, errors.New("No user information")
	}

	user, ok := val.(*User)
	if !ok {
		return nil, errors.New("User information is of the wrong type")
	}

	return user, nil
}

func chooseAPIKey(user *User) (string, error) {
	var key string
	if user.Settings.EncryptedOpenAIKey != "" {
		decryptedKey, err := decryptOpenAIKey(user.Settings.EncryptedOpenAIKey)
		if err != nil {
			return "", fmt.Errorf("failed to decrypt API key: %v", err)
		}
		key = decryptedKey
	} else {
		key = os.Getenv(gc.Env.PublicOpenAIKey)
	}
	return key, nil
}

// Checks if each hashtag exists as a Tag in the database. If it does, it uses the existing Tag's ID and Name.
func associateTagsWithRecipe(recipe *Recipe) error {
	// Initialize a slice to hold the tags that will be associated with the recipe
	var associatedTags []Tag

	// Directly check if each hashtag exists as a Tag in the database
	for _, hashtag := range recipe.FullRecipe.Hashtags {
		// Clean the hashtag
		cleanedHashtag := cleanHashtag(hashtag)

		var existingTag Tag

		// Search for the tag by the cleaned name
		if err := db.Where("name = ?", cleanedHashtag).First(&existingTag).Error; err == nil {
			// Tag exists; use its ID and Name
			newTag := Tag{}
			newTag.ID = existingTag.ID
			newTag.Name = existingTag.Name
			associatedTags = append(associatedTags, newTag)
		} else if gorm.IsRecordNotFoundError(err) {
			// Tag does not exist; create it
			newTag := Tag{Name: cleanedHashtag}
			if err := db.Create(&newTag).Error; err != nil {
				return fmt.Errorf("failed to create new tag: %v", err)
			}

			// Use the newly created tag's ID and Name
			createdTag := Tag{}
			createdTag.ID = newTag.ID
			createdTag.Name = newTag.Name
			associatedTags = append(associatedTags, createdTag)
		} else {
			// Log other types of database errors
			return fmt.Errorf("database error while searching for tag: %v", err)
		}
	}

	// Update recipe's Tags with the associated tags
	recipe.Tags = associatedTags

	// Associate new tags with recipe
	if err := db.Model(&recipe).Association("Tags").Replace(recipe.Tags).Error; err != nil {
		return fmt.Errorf("failed to associate tags with recipe: %v", err)
	}

	return nil
}

func cleanHashtag(hashtag string) string {
	// Convert to lowercase
	hashtag = strings.ToLower(hashtag)

	// Remove spaces
	hashtag = strings.ReplaceAll(hashtag, " ", "")

	// Remove '#' if present
	if strings.HasPrefix(hashtag, "#") {
		hashtag = hashtag[1:]
	}

	return hashtag
}
